## JVM内存结构

JVM内存结构大致分为三个主要区域：

- 堆内存
  - 老年代
  - 新生代
    - Eden
    - From Survivor
    - To Survivor
- 方法区
- 栈内存
  - java虚拟机栈
  - 本地方法栈

### 堆内存（Heap）

堆是JVM内存中最大的一块，用于存储所有对象实例，也就是new出来的实例，几乎所有的实例都在堆中分配内存。

堆内存中实际上被分为两大部分，分别为新生代和老年代，他们所占的比例默认为1:2，可以通过参数
`-XX:NewRatio`进行重新分配。

同时，新生代又被分为三部分分别是Eden，From Survivor、To Survivor三个区域，他们所占的比例默认为8:1:1，可以通过参数`-XX:SurvivorRatio`进行重新分配。

### 方法区（Method Area）

方法区也称为"永久代"，用于存储虚拟机加载的类信息、常量、静态变量，是各个线程共享的内存区域。

JDK8之后，"永久代"被移除，取而代之的是处于本地内存区域中（堆外内存），称之为元空间。原因是由于"永久代"的调优十分复杂，由于项目的不确定性，类的总量，常量池大小等因素都无法确定，因此"永久代"的内存大小很难规定，而一旦发生类的元数据超过"永久代"大小就会抛出OOM异常。 元空间的最大可分配内存就是系统可用内存空间，可以有效的避免内存溢出。

### 虚拟机栈（JVM Stack）

Java虚拟机栈是线程私有的，在线程创建时创建，生命周期与线程一致。

虚拟机执行java程序时，每个方法都会在Java虚拟机栈中创建一个栈帧，然后通过压栈和出栈的方式进行方法的调用。每一个栈帧存储的内容为：局部变量表、操作数栈、动态连接、方法出口等。

> 局部变量存储在Java虚拟机栈中的栈帧中的局部变量表中。如果局部变量是基本类型，则存储的是变量值，如果是引用类型，则存储的是引用地址

### 本地方法栈（Native Stack）

本地方法栈与虚拟机栈的区别仅在于本地方法栈仅对虚拟机中的Native方法服务。

### 程序计数器（PC Register）

程序计数器的功能用于记录当前线程执行的位置，通过改变计数器值来确定执行下一条指令。比如循环、分支、方法跳转、异常处理、线程恢复等都依赖程序计数器完成。

由于程序计数器是为线程服务的，因此每一个线程都维护了自己专用的程序计数器，也就是程序计数器属于线程私有。

### 内存参数设置

-Xms 设置堆的最小内存

-Xmx 设置堆的最大内存

-Xmn 设置新生代大小

-XX:NewSize 设置新生代最小空间大小

-XX:MaxNewSize 设置新生代最大空间大小

-XX:PermSize 设置永久代最小空间大小

-XX:MaxPermSize 设置永久代最大空间大小

-Xss: 设置每个线程的堆栈大小

-XX:+UseParallelGC 设置垃圾收集器为并行收集器。该配置仅对新生代生效，在该配置下，老年代仍然使用默认的串行收集器进行垃圾回收

-XX:ParallelGCThreads=20 设置并行收集器的线程数，即同时启动20个线程进行垃圾的并行收集。该值最好与处理器数目相等。

## JVM的垃圾回收算法

了解垃圾回收算法首先介绍一个专有名词：`GC Root`后文中提到的根节点指的就是`GC Root`。常见的`GC Root`有：

1. 通过SystemClassLoader或者BootClassLoader加载的class对象。通过自定义类加载器加载的类不一定是`GC Root`
2. 处于激活状态的线程
3. 栈中的对象
4. 正在被用于同步各种锁对象
5. JVM自身持有的对象，比如系统记载器等



### 标记清除

标记-清除算法分为标记阶段和清除阶段，在标记阶段，系统会从根节点（请求调用链的初始位置）出发，对所有被引用的对象进行标记。等到清除阶段，系统就会回收没有被标记的对象。

**适用场景**

- 存活对象较多的情况比较高效（降低了回收压力）
- 适用于老年代

**缺点**

- 扫描整个空间两次，消耗资源

### 复制算法

复制算法也是从根节点开始扫描，标记出所有存活对象，并将这些对象全部复制到一块新的内存（连续），接着把原来的内存全部回收。

**适用场景**

- 存活对象较少的情况比较高效（降低的复制压力）

- 适用于新生代

  > 新生代的对象很不容易存活

**缺点**

- 需要一块空的内存空间
- 需要复制和移动对象会有所消耗

### 标记整理（标记压缩）

标记-压缩算法主要用于老年代（存活对象较多），该算法基于标记-清除算法进行优化。

首先需要从根节点对所有可达对象进行标记，但是之后并不是简单的清除未标记对象，而是将所有存活的对象压缩到内存的一端。之后，回收掉处于边界外的内存空间。

**优点**

- 避免内存碎片产生

  > 内部内存碎片：已经分配出去的内存但是无法被完全利用（已分配但没有利用，浪费）
  >
  > 外部内存碎片：由于某空闲表太小而无法分配给新进程（未分配导致无法利用，无奈）

- 无需新的内存空间
- 性价比高

### 分代收集算法

分代收集算法是目前虚拟机使用的一种算法。该算法的结果使得在不同的"代"根据不同的特点使用最合适的回收算法，如：新生代由于对象存活率低，所以可以使用复制算法。而老年代存活率高，没有额外的空间对其进行分配担保，所以选择使用标记清除算法或者标记整理算法。

## 垃圾回收机制

### 回收流程

- 新产生的对象首先会存储在Eden区中

- 当Eden中存满时，就会把Eden区中存活的对象复制到From区，然后回收Eden全部空间

  >  若某个对象太大导致From区也放不下，那就直接全部丢进老年代

- 此时Eden继续接收新产生的对象直到再一次放不下时，就会把Eden区以及From区的存活对象移动到To区，然后回收Eden和From区内存。

  > 若因为存活对象太大导致To区装不下，那就直接全部丢进老年代

- 当From渠也满时，就会将当前存活对象复制到To区，接着回收From区。然后To和From交换身份。

  > 由于这样的机制，实际上To区指向的一直是那个被全部回收后的区，也就是空区。

- 如上述过程，大多数对象会被不断的进行复制，当复制次数操作15次时，对象就被转移至老年代

  > 被复制多少次进入老年代可通过 -XX:XX:MaxTenuringThreshold 参数进行配置

- 最后当老年代的内存也满时，则触发`Full GC`

  > Full GC由于耗时很长，对资源的消耗也很严重所以生产中我们应当尽可能避免Full GC的发生

### 垃圾回收的两种类型

分别为`Minor GC`和`Full GC`，`Full GC`也称之为`Major GC`。

- **Minor GC**

  对新生代进行回收，不会对老年代产生影响。由于新生代的对象死亡频繁，因此`Minor GC`也十分频繁，因此通常使用算速度快，效率高的算法，使垃圾能够在短时间内得到回收。

- **Full GC**

  对整个堆内存进行回收，包括新生代和老年代。由于该回收机制需要对整个堆空间进行回收，因此其耗时严重，我们需要尽可能减少`Full GC`的次数。

  > 老年代被写满、持久代(JDK8前存在)被写满、System.gc()被显式调用等都会导致Full GC

## 垃圾收集器

垃圾收集器总共分为七种，分别为：

### 新生代收集器

​	`Serial` 串行收集器-复制算法
​	`PraNew` 并行收集器-复制算法
​	`Parallel Scavenge `并行回收收集器-复制算法

### 老年代收集器

​	`Serial Old`
​	`Parallel Old`
​	`CMS`

### 全堆收集器

​	`G1`

### 并行和并发的区别

>  假设现在有三个作业需要完成。

- 一个员工一个一个的做就是最普通的**串行**。
- 三个员工同时开始做就是**并行**。
- 有一个员工三个作业都会做，于是他一会做A作业一会做B作业又一会做C作业，这就是**并发**。

**并发**并不是强调只有一个员工，而是强调同一个员工可以做多件事。

一个"员工"可以理解成一个"线程"。

## JVM优化

在实际开发生产中，JVM的优化的主要原因就是为了`GC`的频率和减少`FULL GC次`数。原因是GC会消耗时间和资源，特别是`FULL GC`由于需要回收整个堆空间，所以耗时较长。

### 优化步骤

- **监控GC状态**

  使用各类JVM工具、查看当前日志、分析JVM配置、分析GC日志、查看各区域的GC时间等

  > 当发现同一内存区域的GC时间越来越长、FULL GC的次数越来越多、且执行FULL GC后，老年代的内存没有得到有效的内存释放时，就已经出现了系统即将崩溃的迹象，此时就需要对JVM的内存快照dump进行分析，以找到致命源。

- **生成dump文件**

  服务器中可以通过jmap命令生成对应的dump文件。

  其他方式自行搜索。

- **分析dump文件**

  使用对应的工具打开dump文件，然后分析（分析方法略） 

  ​	分析后如果满足下面的指标，则一般不需要进行GC优化：

  -  Minor GC执行时间不到50ms；
  -  Minor GC执行不频繁，约10秒一次；
  -  Full GC执行时间不到1s；
  -  Full GC执行频率不算频繁，不低于10分钟1次；

- **GC优化**

  查看系统内存分配是否合理，是否可以进一步加大老年代的内存空间。

  GC收集器是否合适，是否有必要更换效率更高的收集器。

  对JVM的各个参数进行合理调整，然后进行灰度测试，与未优化的机器进行比较查看效果。

  不断分析，不断调整，找到最合适的JVM参数然后应用。

  

