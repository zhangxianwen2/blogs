## 小伙子，看你简历上写了Redis，说说为啥使用Redis？

因为传统的关系型数据库比如mysql已经不能适应所有的场景，比如秒杀系统的库存扣减，访问流量高峰等问题很容易就把这样的关系型数据库压垮，所以引入了Redis这样的缓存中间件。同时又因为系统中涉及到一些经常访问但是数据源处于其他系统中的资源，在访问该系统时接口响应周期过长，所以也引入了Redis这样的缓存中间件作为这类数据的临时落脚点。目前是市面上比较常用的缓存中间件有Redis和Memcached，我们综合考虑了一下他们的优缺点，最终选择了Redis。

1. 缓存，经常访问的但是又不会频繁变动的数据进行缓存，加快接口响应
2. 分布式锁的需求
3. 简单的消息队列，模拟生产者和消费者

### memcache和redis的区别

**一、支持的存储类型不同**

memcache和redis都是内存型数据库，memcache不仅能存储String类型，还能存储图片、文件、视频等格式的文件。而redis则提供了string、set、hash、list等存储结构。相比于redis，memcache能存储文件数据的需求并不是那么强烈。

**二、数据落盘**

memcache的数据不可恢复，一旦机器挂掉，所有数据都丢失。redis支持数据持久化并支持RDB和AOF两种方式。

**三、内存空间与数据量**

redis中的数据一旦达到物理内存限制，会将value值转移到磁盘中，redis的value值大小可以达到1GB。

memcache的value值大小只能有1MB

**四、适用场景**

1. redis适用于会话缓存，因为redis具备持久化机制。当系统设计时对数据一致性不严格时如果memcache炸了，那么用户就会获取到空数据。
2. redis因为有持久化机制，做全页缓存时，就算redis重启，前端访问页面依然会很快（因为redis重启后会进行数据恢复）。
3. Redis提供的list存储结构中的push和pop操作可以做队列，memcache则不行
4. redis还可以做网页排行榜和计数器，redis在内存中对数字的增加递减实现得非常到位。
5. redis适用于对缓存数据内容有一定的结构化要求的场景，同时更适用于对数据的安全性有很高要求的场景。

**五、memcache的优势**

聊了这么多全是redis吊打memcache的，其实人家也是有优势的，相比于redis，memcache在进行kv存储时，内存利用率会更高（但如果redis使用hash结构来做kv存储的话，内存利用率会高于memcache）；由于redis只使用单核，而memcache使用多核，所以当数据量增加上来之后（大概100KB+），memcache的性能要比redis略高。

## 小伙子，你知道Redis有哪些存储结构吗

String、Hash、Set、SortedSet、List

### String

关于String在redis中的内存分配：当字符串长度小于1MB时，每次扩容对当前空间进行加倍；当字符串长度大于1MB时，每次扩容只会扩展1MB。最大扩容至512MB

**应用**于常见的key-value存储场景，还能做数字的递增和递减

### List

当数据量较少时，redis会将这些数据存储在一块连续的内存空间中（ziplist），当数据量较多时，则变成快速链表结构（quicklist）。快速链表支持向前遍历和向后遍历，但是和普通的双向链表不一样的是，快速链表不维护prev和next指针域，而是在ziplist的基础上增加了一个zltail_offset（最后一个元素距离起始位置的偏移量,用于快速定位到最后一个结点）字段，快速到达最后一个结点然后倒着遍历。

在List中，所有的数据是存放在一个个的entry中。倒着遍历时，是通过entry中的prevlen属性获得前一个entry的长度进行快速定位的。

由于list是通过数据插入顺序进行排序的，因此可以被**应用**的场景还挺多：

**消息队列：**lpop和rpush（或者反过来lpush/rpop）即可实现队列功能；注意，当队列为空时，就会进入pop无限循环，占用CPU资源，当pop为空时，我们可以通过让线程sleep一秒钟再继续。亦可通过blpop和brpush（或者反过来brpop/blpush）实现延时队列，当pop为空时阻塞等待一段时间，又要注意，blpop的阻塞等待时间过长时，就会抛出异常，需要手动对异常进行try catch。

**按照时间进行排序的列表：**比如最新的n条评论、最近的n个访客等。通过lpush往list中塞最新元素，再lrange取出元素即可获得最新的n条数据。（lrange支持自定义获取元素区间）

### Hash

Redis中的hash和Java的Hashmap类似，都是数组+链表结构，当发生hash碰撞时会把元素追加到链表上。但是值得注意的是，redis中的hash的value值只能是字符串。

hash和String都可以用来存储信息，不同的是，hash着重于存储具有一定数据结构的数据，而String则存储经过序列化都的一段字符串。当二者同时对存储的一个用户多个信息有修改需求时，String需要取出数据解析后修改，然后重新序列化成字符串存入。而hash则支持直接对需要修改的值进行修改。但是hash比string占用更大的内存空间。

**应用：**存储结构化数据对象

### Set

无序集合，和Java中的HashSet类似，键值对无序且唯一。当集合中最后一个元素被删除时，数据结构自动删除，内存被回收

**应用：**

1. 好友、关注、粉丝、喜好等集合，通过sinter命令获取A和B的共同好友；通过sismember判断A是否是B的好友；类似这样的交集、并集、差集
2. 随机展示；比如美团首页的推荐商家需要对商家数据进行随机展示时，可通过srandmember命令随机获取。
3. 因为天然去重功能，可以在抽奖活动中用于存储用户的编号，以保证同一用户不会抽中两次

### ZSet(SortSet)

zset拥有set的特性，可以保证内部value的唯一，另一方面zset给每个value赋予了一个score，代表这个value的排序权重。它的内部使用的是一种叫做“跳跃列表”的数据结构。

跳跃链表如下图所示：

![1585460856343](C:\Users\zhangxianwen\AppData\Roaming\Typora\typora-user-images\1585460856343.png)

查找的步骤是从头节点的顶层开始，查到第一个大于指定元素的节点时，退回上一节点，在下一层继续查找。

**应用：**

排行榜，和list的排行榜不同在于zset可以作为动态排行榜（list必须基于时间的先后顺序），比如：点赞量排行、关注量排行等。（也可以使用时间作为分数实现list那样的排行）

大批量数据的数据累加，比如有千万条包含不同类别的订单需要对订单的金额进行累加，最后根据类别进行排序。就可以使用类别作为value、金额作为score

### 加分

除了以上五种基本数据结构，redis实际上还支持很多其他数据结构，随意说一种就是加分项。 挑一个最简单也是最经典的BitMap讲一下。

首先介绍一下布隆过滤器，BloomFilter简单的说就是：通过将一个key的hash值分布到一个大的bit数组上面，判断一个key是否存在时只需判断该的hash对应的bit位是否都是1，如果全是1则表示存在，否则不存在。
优点：性能很高主要在hash算法上面，空间占用小，能够极大的缩小存储空间。
缺点：存在误判。既对应的bit位刚好被其他的key置为1了（因此一般情况下，在进行hash的时候我们会进行多次hash计算用以降低误判率）。

Redis中的BitMap就是用来存储一个大bit的，因此就支持BloomFilter了。举个例子：

有一个表格中存在1亿条数据，现在给你一个数据让你判断这个数据在不在这一亿条数据里。无论是使用关系型数据库还是链表存储还是查找树存储，在如此庞大的数据量下，都显得非常鸡肋。但是使用BloomFilter的话，只需要将这些数据逐个计算出hash值并且调用redis的setBit方法（最好是通过pipeline进行包装，n个value值一起setBit）。当需要判断是否存在时，将数据经过相当的hash计算并通过redis的getBit方法即可返回是否存在。

为了防止误判（概率很低），只需要在发现有数据存在时前往DB确认一下即可。

## 如果有大量的key需要设置同一过期时间，需要注意什么

当很多key在同一时间过期，在该时间点，redis可能会出现突然的卡顿现象。更严重的是，如果这批过期的key在恰好过期时，大量的请求涌入，那么所有请求都会跑到DB，会造成缓存雪崩。

## 你使用过Redis分布式锁？说说它是怎么一回事

redis锁通过setnx争抢锁，抢到之后，使用expire增加锁过期时间防止锁一直占用不被释放。

问题在于这两条操作不是原子的，如果执行expire时机器故障，就会导致锁一直得不到释放，因此在操作的时候可以使用lua脚本将两条语句连在一起，实现原子性。

**加分：**除了setnx外，Redis中还可以使用RedLock实现，RedLock下去了解。

## Setex可以做锁吗

不可以，setex会在设置一个key的同时给key设置一个过期时间，但是setex遇到重复key时会覆盖原来的值，客户端不能根据这样的机制判断该key是否被锁。

## 假如现在数据库中存在1亿个key，其中有10W个key使用了相同的前缀，怎么找出这10w个key

两种方式：

1. keys指令获取指定模式的key列表。特点：因为redis是单线程的，keys命令会阻塞当前业务，知道指令执行完成
2. scan指令获取指定模式的key列表。特点：scan命令可以不阻塞地提取出指定模式的key列表，但是会有一定的重复几率，需要在客户端进行手动去重，同时scan命令将比keys命令花费更长的时间。

## 为什么scan有重复几率

这个就涉及都scan命令的遍历机制，scan属于增量式迭代命令，每一次执行返回两个元素，第一个是告诉我下一次scan的游标是多少，当游标变回0时，表示遍历结束。对于scan返回的游标，如果在返回游标P后，有一些key因为过期或者删除，导致原来的数据变少，那么scan通过P定位遍历位置时，就有可能发生向前偏移，导致重复获取数据。默认情况下，scan命令每次返回10条数据，我们可以通过count参数自行设置每次迭代返回多少条。

> 当[SCAN](http://www.redis.cn/commands/scan.html)命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。

这个点讲得不是很清楚，涉及到scan的源码，感兴趣的可以自行百度了解一下。

## 使用Redis做过队列吗，怎么做

一般使用list作为队列，lpush生产消息，rpop消费消息。

## 当pop没有消息时，会发生什么

当pop没有消息的时候会一直不断的重复pop，造成CPU浪费，这时候可以设置线程sleep一会（1秒）。还可以通过brpop实现阻塞队列，这个命令会一直阻塞知道消息到来（可以自行设置阻塞等待时间）。但是brpop在阻塞时间过长时有可能抛出异常，需要在程序中合理处理。

## 有没有一次生产多次消费的方案

使用pub/sub订阅者模式（分别对应publish命令和subscribe命令），可以实现1:N的消息队列。缺点是一旦消费者下线，消息就丢了。所以通常在这类场景中我们会使用比较专业的消息中间件比如rabbitMQ。

## Redis如何实现延时队列

可以使用zset，score放置执行消息的时间戳，当一个消息被添加到zset后便会按照时间戳进行排序。客户端只需要起一个线程不断轮询获取zset的第一个元素判断score是否小于等于当前时间戳，若小于则取出来消费并且删除，否则结束。

缺点是：获取消息和删除消息是两条命令，不具备原子性。（可以通过lua脚本解决）

所以通常在这类场景中我们会使用比较专业rabbitMQ中间件完成延时队列

## Redis如何持久化

分别是RDB和AOF两种方案。

RDB是定时将当前实例中的所有数据生成一份快照存储到磁盘，但是因为RDB耗时较多，会导致大量数据的丢失。

>  RDB在配置文件的save参数处配置，手动执行时使用save或者bgsave（bgsave开启子进程执行。save则直接阻塞）

AOF是以增量的方式对redis的每一条操作指令进行持久化，类似于打日志的方式，通过sync属性可以设置同步间隔时间，AOF持久化即使是遇到机器宕机，也只会损失很少量的数据。（如果机器足够强大，可以设置成每执行一条命令就做一次AOF，这样就能保证数据一点都不丢）

> AOF在配置文件的appenonly处配置，手动执行使用bgrewriteaof

当设置了两种持久化方案时，redis重启会优先使用AOF文件进行数据恢复。

## RDB的实现原理

在进行RDB时，redis会调用系统函数fork()生成一个子进程来进行RDB操作，同时，在调用fork时(仅在fork时会造成服务阻塞)会使用写时复制(copy-on-write)策略，即fork函数发生的一刻父子进程共享同一内存数据，这使得在fork期间，父进程的操作将被实时复制到子进程中。

缺点：一次RDB操作可能耗费好几分钟，也就是说两次RDB持久化之间都会存在一段不短的时间间隔，一旦在这个间隔内机器宕机，那么这短时间内的数据将丢失。

## AOF的实现原理

每当一个命令写入redis，该条命令就会被存储到AOF缓冲区，该缓冲区会针对appendfsync配置用不同策略向磁盘做同步操作，并对原AOF文件进行重写。

> 这里介绍一下appendfsync参数的可配置值
>
> - always：命令写入aof缓冲区后，每一次写入都需要同步，**直到写入**磁盘（阻塞，系统调用fsync）结束后返回。显然和Redis高性能背道而驰，不建议配置
> - everysec：命令写入aof缓冲区后，在写入系统缓冲区**直接返回（系统调用write）**，然后有专门线程**每秒**执行写入磁盘（阻塞，系统调用fsync）后返回
> - no：命令写入aof缓冲区后，在写入系统缓冲区**直接返回（系统调用write）**。之后写入磁盘（阻塞，系统调用fsync）的操作由**操作系统负责**，通常最长30s

## 管道Pipeline了解吗？为什么使用管道

管道可以将多条指令一次发送到redis，让多次IO减少为1次。需要注意的是，管道中的指令没有因果相关性。

## Redis的同步机制了解过吗

Redis同步发生在redis的主从或者从从节点中，当一个新的节点加入时，会发送SYNC命令到主节点，主节点收到命令后开始执行RDB持久化，同时将在此之后的写命令进行缓存。当RDB持久化结束后，将RDB文件发送给从节点（此时新的写命令依然持续往缓存中写入），从节点进行数据初始化，待初始化完成后，主节点再将此前已经缓存的写命令同步给从节点，从节点执行这部分写命令。完成同步。

## Redis集群了解过吗

Redis集群方案又Redis Sentinal哨兵模式和Redis Cluster。

哨兵模式着眼于高可用，会在master宕机后推选出一个slave作为新的master继续提供服务，同时哨兵模式还具备故障转移、消息通知、集群监控、配置中心等功能。

Redis Cluster着重于服务的扩展，当单个redis内存不足时，使用Cluster进行分片存储。





