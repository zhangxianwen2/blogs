## TCP三次握手

[为什么 TCP 建立连接是三次握手，关闭连接确是四次挥手呢？](https://www.jianshu.com/p/fd27a7ffdec4)

## HashSet的add方法如何判断重复的

查看HashSet的源码根据该类的构造函数可知，HashSet实际上就是维护了一个HashMap，不同的地方就是add方法，因为HashSet拥有自动去重的功能。

在执行add方法时，实际上是往HashMap中put了一个`key`值为`add参数`（也就是把Set的入参值当做HshMap的key值）`value`为`new Object()`的键值对。而由于HashMap不支持key值重复，所以当发现该key值与自己维护的数据中心存在重复key时就会返回null。当HashSet发现返回null后，就判定对象重复。

> HashMap在put一个键值对时，会使用当前key的hash值与已存在的key的hash值做比较，当发现一样时，再调用对象的equals方法判断两个对象是否相同，当相同时，判定为重复key。

## `==`和`hashcode( )`和`equals( )`

### ==和equals( )

实际上`equals`方法与`==`运算符一样，都是比较两个对象的地址是否一样，一样则返回true，否则返回false；

对于基本数据类型，这二者直接比较他们的值。

对于引用类型则是比较其引用地址。我们都知道，对象的引用地址是存放在栈内存中的（对象实例在堆内存中），也就是说，这二者的判断都是在栈中取的数据。所以，如过你需要比较对象的内容，则需要重写引用类型对象的eqauls方法获取堆中的数据进行比较了。

### hashCode（）

哈希code方法会返回一个int类型的数字，这个是基于对象所在的物理内存地址经过一系列计算而得，因此，我们可以简单的理解成可以映射该对象所处的内存地址（当然实际上不是这样的）。

有了这样的知识基础，我们来谈一下hashCode()的作用？

equals方法只能通过一对一的方式进行两个对象的比较，当数据集十分庞大时，若要判断数据集中是否存在重复的对象，则需要进行大量的equals计算。但是hashCode改变了这一状态，任何一个值都会存在自己的唯一的hashCode值，而同一个对象由于处在同样的物理内存地址，因此其hashCode值也是一样的，介于此，当一个数据集中需要添加新的对象时，我们只需要获取该对象的hash值然后看下这个hash值对应的位置是否已存在对象即可。如果不存在，则说明没有对象重复直接添加。当存在时，则需要考虑**hash冲突**的问题，此时仍然需要通过equals方法进行二次确认两个对象是否属于同一个，如果属于，则判定重复。否则，就会根据对应数据集的数据结构进行进一步处理。

> 比如在HashMap中，当出现hash冲突时，会在同一位置以链表或者红黑树的形式进行对象的存储。
>
> 由于hash算法的结果长度固定，而需要计算hash的数据是无穷的，所以当数据量变大后，hash散列的概率就变低，导致出现hash冲突也叫hash碰撞

## 控制反转 IOC

控制反转实际上不是一种技术而是一种思想。在Java中，IOC的思想意味着将你设计好的对象交给容器进行控制，而不是你在需要的时候手动去获取。也就是我们所说的：这些对象都在我这里保管，你别找我要，你需要的时候我会主动给你配上的。

提到IOC，就不得不提到`DI 依赖注入`，通过依赖注入，系统各个组件之间的依赖关系就由系统容器统一管理，通过依赖注入机制，我们只需要进行简单的配置即可获取到我们想要的资源，而无需编写代码获取。真正的实现，不关心对象从何而来，由谁实现，我要用，你给我就完了。

### SpringIOC的启动过程

- 首先会由BeanDefinitionReader读取xml文件、@Autowrite、@Configuration等配置的Bean信息
- 然后将这些Bean放置到Spring容器中的Bean注册表中
- 接着根据Bean注册表`BeanDefinitionRegistry`对其中的Bean通过`InstantiationStrategy`进行实例化，将通过实例化对象（Bean实例）再放回Spring容器中的Bean缓存池（缓存池由HashMap实现）里
- 最后就是等待应用程序的使用

## 可重入锁

可重入锁是为了在某种情况下发生死锁的解决方案。我们熟悉的synchronized和ReentrantLock都是可重入锁。

可重入锁的原理：可重入锁中维护了一个计数器变量，当改变量为0时表示锁处于释放状态，任何线程都可以获取。当某个线程获取到第一个锁时，计数器就会执行+1操作变为1，接着发现同样的线程再一次需要这个锁，此时重入锁发现是同一个线程，就耐心地执行计数器+1操作。而在线程逐步释放锁的过程中，计数器就执行-1操作，当计数器最终结果为0时，锁被释放。

重入锁的应用场景举例：

```java
public class A{
	private synchronized void lockOne(){
		// do something
		lockTwo();
	}
	
	private synchronized void lockTwo(){
		// do something
	}
}

在这个类中我们可以发现，当调用同步方法lockOne时，线程将获取一把A对象（方法所处类对象）的锁，在lockOne中调用lockTwo时，获取的还是同一把锁，只不过是锁种的计数器执行了+1操作。这就是重用锁的应用场景。
```

## Switch是否可以使用String作为参数

在jdk1.7之后就支持了，但是实际上Switch对字符串的支持也是通过获取该字符串的hashCode来进行处理。也就是说，实质上，对于Switch底层，仍然处理的是int类型的入参。

## HTTP和HTTPS

**HTTP：**超文本传输协议，不对传输内容进行加密，安全性差。

**HTTPS：**超文本传输安全协议，对传输内容使用SSL/TLS进行数据包加密，安全性好。

HTTP传输速度比HTTPS快，因为HTTP传输数据只需要TCP的三次握手，而HTTPS在HTTP三次握手的基础上还需要SSL握手9次（9个数据包）。

HTTPS实际上就是在HTTP是基础上增加了SSL/TLS协议，因此HTTPS比HTTP更加耗费服务器资源。

## OSI七层模型

**第七层	应用层**	各种应用程序协议，如：HTTP、FTP、SMTP等

**第六层	表示层**	信息的语法语义以及他们的关联

**第五层	会话层**	不同机器上的用户之间建立和管理会话

**第四层	传输层**	接手上一层数据，必要时对数据进行分割，并将数据交给网络层

**第三层	网络层**	控制子网运行

**第二层	数据链路层**	物理寻址

**第一层	物理层**	机械、电子通信通道上的原始比特流传输

## TCP三层模型

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190105164025264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNjIy,size_16,color_FFFFFF,t_70)

## CAP和BASE

### CAP理论

定义：一个分布式系统中最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

**Consistency（一致性）**

是指更新操作成功并且返回客户端完成后，所有节点字同一时刻的数据完全一致，因此一致性说的是数据一致性。

对于一致性，可以从客户端和服务端分别理解：

> 分布式服务存在多个服务端，当一个服务端的数据被更新时，需要保证其他服务端的数据也能保持一致

​	`客户端一致性`	客户端在多并发访问时获取到的数据是否是最新的。（服务端A节点更新了数据，客户端到B节点获取数据能够获取到A节点更新后的数据）

​	`服务端一致性`	当某个节点的数据被更新后，如何将更新结果同步到其他节点保证整个系统的数据一致。

三种一致性策略：

- 强一致性：对于关系型数据库，要求更新过的数据能被后续的所有请求都访问到。
- 弱一致性：能容忍后续的部分或者全部访问都访问不到
- 最终一致性：经过一段时间后要求所有的访问都能访问到更新后的数据

>  注意：CAP理论中说的不能同时满足的一致性指的是强一致性。

**Availability（可用性）**

可用性是指服务一直可用，而且是正常响应时间。

好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者系统超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如：负载均衡、web服务器、应用代码、数据库服务器等，任何一个节点不稳定都会影响到可用性。

**Partition Tolerance（分区容错性）**

是指分布式系统在遭遇某个节点或者网络分区出现故障时，仍然能够对外提供满足一致性和可用性服务。分区容错性强调虽然应用是一个分布式系统，但是看上去好像是一个可以运转的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔为独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。

简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作（当网络异常导致数据未同步时就会一直等待直到数据同步后返回，违反了可用性），就是有比较好的分区容错性。

**为什么只能同时满足两个呢**

`CA without P`	如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。

`CP without A`	如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。

 `AP wihtout C`	要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。

### BASE理论

BASE理论是CAP理论的延伸，核心思想是即使无法做到强一致性，就是用合适的方法达到最终一致性。

BASE主要是指：基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）

**Basically Available（基本可用）**

基本可用是指分布式系统在出现故障时，允许牺牲一部分的可用性（牺牲用户体验），即保证核心可用。

电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。

**Soft State（软状态）**

软状态是指允许系统存在中间状态，而该中间状态不影响服务的整体可用性。分布式系统中，多个数据副本间的的同步允许延时就是软状态的体现。

**Eventual Consistency（最终一致性）**

最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

## Bean 的生命周期

面试时被问到bean的生命周期，一般是指Spring中Bean的生命周期。我们都知道，在Java中，Bean的生命周期就是从new实例化诞生，用完之后被回收就结束。但是Spring中的Bean生命周期更加的复杂：

1. Spring启动时就会查找项目中需要实例化的bean，进行Bean的实例化

2. Bean实例化后将对Bean的引用和值填充到Bean的属性中

3. 如果实现了BeanNameAware，调用BeanNameAware的setBeanName(String var)设置bean的id

4. 如果实现了BeanFactoryAware，调用BeanFactoryAware的setBeanFactory(BeanFactory var)设置BeanFactory（Bean工厂）

5. 如果实现了ApplicationContextAware，调用ApplicationContextAware的setApplicationContext(ApplicationContext var)接口设置ApplicationContext

   > 注意，这三个Aware接口setXXX方法的意思不是像容器设置值，而是从容器中获取对应的值给你进行自定义的处理。实际上，三个接口的入参就是他们代表的内容了，是给你用的，不是需要你来设置。不要被set字样搞混了。

6. 如果实现了BeanPostProcessor，则调用postProcessBeforeInitialization初始化前的后置处理方法

7. 如果实现了InitializationBean接口，则使用afterPropertiesSet()接口来初始化属性

8. 如果实现了BeanPostProcessor，则调用postProcessAfterInitialization初始化后的后置处理办法

9. 此时，Bean就可以使用了

10. 如果实现了DisposableBean接口，当容器关闭时时，就会调用DisposableBean接口的destory方法对Bean进行销毁。

## VOLATILE的可见性和有序性

volatile修饰的字段被变更后会立刻更新到主存，同时通知所有使用该字段的线程：嘿，这个值被我改变了，你们重新取。 以此达到了字段的**可见性**。

对于有序性，由于编译器和处理器会对计算机指令进行重排序。当字段被Volatile修饰后，能保证其本身在指令的顺序中不会被改变，但是对其他指令是否不被重排序没有效果。称之为volatile的**部分有序性**。

## Thread 类中的start() 和 run() 方法有什么区别？

start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

## Java多线程中调用wait() 和 sleep()方法有什么不同？

java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。

## Java线程池中submit() 和 execute()方法有什么区别？

两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。

## HTTP和RPC的联系与区别