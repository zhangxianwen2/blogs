## 二叉查找树 `BST`

### 定义

二叉查找树定义了任何一个节点的左子节点值比该节点值小，右子节点的值比该节点的值大。该二叉树的高度就决定了该数据结构的查找效率。

在**理想的情况**下，二叉查找树的是左右平衡的，时间复杂度为`O(logN)`，其中N为节点数。**最坏的情况**是所有的节点都在左边或者都在右边，此时时间复杂度为`O(N)`。

![img](https://pic1.zhimg.com/80/v2-e64df5b2126506c59bad4604d298d818_hd.png)

### BST的查找操作

```
T key = ${someValue};    // 目标查找的值
Node root = ${rootNode};  // 初始化root为二叉树的根节点

while(true){
	if(root == null){ // 当前节点为空时，表示遍历完了都没找到目标值
		return null;
	}
	if(root.value.equals(key)){	// 当前节点值等于目标查找值时
		return root;
	}
	if(key.compareTo(root.value) < 0){	// 节点值大于目标查找值时
		root = root.left;
	}else{	// 节点值小于目标查找值时
		root = root.right;
	}	
}
```

以上程序即是BST查找操作的伪代码，从代码可以解释出。BST的查找操作可以理解为：

	1. root初始化赋值为根节点，从根节点开始查找
 	2. 当发现root的值不为目标值，则使用root值与目标值进行大小的比较
 	3. 如果目标值比较小，则root重新赋值为当前节点的左子节点，否则赋值为右子节点
 	4. 如此这般对整个树结构进行遍历，当遍历到root对应的值等于目标值或者root指向为空时，结束！

### BST的插入操作

```
Node node = ${someNode};	// 表示需要插入的节点
Node root = ${rootNode};	// 初始化root为二叉树根节点
Node parent = null;

while(true){
	if(root == null){
		break;
	}
	parent = root;
	if(node.value.compareTo(root.value) <= 0){	// 当需要插入的节点值小于当前节点值
		root = root.left;
	}else{
		root = root.right;
	}
}

if(parent != null){	// 当为待插入节点寻找到父节点时
	if(node.value.compareTo(parent.value) <= 0){
		parent.left = node;
	}else{
		parent.right = node;
	}
}
```

以上程序即是BST插入一个节点操作时的伪代码，从代码可以解释出。BST的插入操作可以理解为：

1. 确定需要插入的节点的父节点
   1. 从二叉树根节点开始查找，查找逻辑与二叉树查找值的逻辑一直
   2. 不一样的地方在于引入了一个parentNode用于定义需要插入节点的父节点，可以看出，root经过一轮轮的赋值可能会在某时候变成空节点(遍历完了)，而parentNode则正好在root为空节点之前被赋予root节点的信息，如此保证parentNode恰巧就是处于最后一个节点。
2. 将带插入节点以parent为父节点进行插入

### BST的删除操作

删除操作算法较为复杂，所以不贴代码了。讲一下大致的删除步骤和逻辑：

1. 在二叉树中寻找到待删除的节点位置
2. 如果待删除的节点是叶子节点（没有任何子节点），则直接删除
3. 如果待删除的节点不是叶子节点（有子节点），则先查找到到待删除节点中序遍历的后继节点，用该后继节点的值替换待删除节点的值，然后删除后继节点。

> 中序遍历：递归地按照左子树->根节点->右子树的顺序进行遍历。得到的结果是从小到大排列的。

## 红黑树 `RBTree`

红黑树实际上是为了解决二叉查找树存在的问题（不可控制的倾斜）而诞生的，当然，也有一些文章认为红黑树是基于`2-3树`演变来的，无论红黑树是基于那种数据结构，其都很恰当的解决了各种在其他结构树上存在的各种问题。

### 红黑树的应用

Java函数库中的TreeMap和TreeSet

Java8中的HashMap也使用了红黑树替代以前版本的链表实现了性能上的提升

其他的自行查阅

### 红黑树的定义

红黑树自身满足5个定义，针对红黑树的一系列操作都将围绕这这些定义，一旦打破这样的定义，就不被称之为红黑树：

1. 任何节点都有颜色，分为红色和黑色
2. 根节点是黑色节点
3. 父子节点之间不得出现连续的红色节点
4. 任何一个节点向下遍历到其子孙的叶子节点，所经过的黑色节点个数必须相等
5. 空节点被认为是黑色节点

其数据结构如下：

```
class Node<T>{
	public T value;	// 节点值
	public Node<T> parent;	// 父节点
	public Node<T> left;	// 左节点
	public Node<T> right;	// 右节点
	public boolean isRed;	// 是否红色节点
}
```

RBTree实际上仍然满足BST树的定义，因此其也算是一颗BST树，但是与BST不同的是RBTree会在插入或者删除等操作时通过**一定的手段**使整棵树保持平衡，保证树的高度接近于理想的BST。

上一段话中"一定的手段"包括两种：

- 变换颜色（红<->黑）
- 左右旋转

### 对红黑树的划分（个人观点）

我个人对整个红黑树的理解划分为三个部分：

- 必须被符合的定义描述
- 与普通二叉查找树一样的操作方式
- 将不符合定义的节点变成符合定义的节点的算法

三个部分各司其职，各行其政，最终构成一颗红黑RBTree。

完了？完了！没有细节？没有了！

因为太细节的我还弄明白呢。

## 写在最后

参考文章推荐，来自美团技术团队分享的[红黑树深入剖析及Java实现](https://zhuanlan.zhihu.com/p/24367771)